##  如果面试遇到这些问题该如何回答？

### 一、Android 基础

#### 1.什么是 ANR 如何避免它?

A: ANR是指应用程序未响应，Android系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成ANR。ANR由消息处理机制保证，Android在系统层实现了一套精密的机制来发现ANR，核心原理是消息调度和超时处理。

然后我们来看什么样的情况会导致ANR异常，总结起来就是四大组件的响应超时：

（1）Service Timeout:Service在特定的时间内无法处理完成（20s均为前台）
（2）BroadcastQueue Timeout：BroadcastReceiver在特定时间内无法处理完成（10s）
（3）ContentProvider Timeout：内容提供者执行超时
（4）inputDispatching Timeout: 按键或触摸事件在特定时间内无响应。（5s）

具体的的场景如：

1. 应用在主线程上非常缓慢地执行涉及 I/O 的操作。
2. 应用在主线程上进行长时间的计算。
3. 主线程在对另一个进程进行同步 binder 调用，而后者需要很长时间才能返回。
4. 主线程处于阻塞状态，为发生在另一个线程上的长操作等待同步的块。
5. 主线程在进程中或通过 binder 调用与另一个线程之间发生死锁。主线程不只是在等待长操作执行完毕，而且处于死锁状态。如需更多信息，请参阅维基百科上的[死锁](https://en.wikipedia.org/wiki/Deadlock)。

解决方式：

将所有的耗时操作都放在子线程去处理，保证UI的顺畅。

#### 2. Activity和fragment的生命周期？

A：Activity的生命周期耳熟能详，如下所示：

![](https://upload-images.jianshu.io/upload_images/2244681-1532340d63d59dc6.png)

Activity是四大组件之一，除了上述的生命周期之外额外需要注意的还有：

1. onNewIntent，栈内复用
2. onActivityResult 跳转到另一个Activity后，返回到之前的Activity会调用
3. onSaveInstanceState 和onRestoreInstanceState 当系统意外停止activity时，它会调用onSaveInstanceState()存储一个Bundle 对象并将数据传递给onCreate和onRestoreInstanceState。由于该方法不一定会被调用，这里最多只能做一些临时性数据的存储，持久化操作还是建议放在必定会调用的生命周期中。

下面是Fragmet 的生命周期：

![](https://upload-images.jianshu.io/upload_images/2244681-3685a0866eb07d3a.png)

fragment的生命周期中需要注意的方法：

1. onAttach：onAttach()回调将在Fragment与其Activity关联之后调用。
2. onCreate(Bundle savedInstanceState)：此时的Fragment的onCreat回调时，该fragmet还没有获得Activity的onCreate()已完成的通知，所以不能将依赖于Activity视图层次结构存在性的代码放入此回调方法中。在onCreate()回调方法中，我们应该尽量避免耗时操作。此时的bundle就可以获取到activity传来的参数
3. onCreateView(LayoutInflater inflater, ViewGroup container,
    Bundle savedInstanceState)： 其中的Bundle为状态包与上面的bundle不一样。
    **注意的是：不要将视图层次结构附加到传入的ViewGroup父元素中，该关联会自动完成。如果在此回调中将碎片的视图层次结构附加到父元素，很可能会出现异常。**
4. onActivityCreated：onActivityCreated()回调会在Activity完成其onCreate()回调之后调用。在调用onActivityCreated()之前，Activity的视图层次结构已经准备好了，**这是在用户看到用户界面之前你可对用户界面执行的最后调整的地方。**
5. Fragment与Activity相同生命周期调用：接下来的onStart()\onResume()\onPause()\onStop()回调方法将和Activity的回调方法进行绑定，也就是说与Activity中对应的生命周期相同，因此不做过多介绍。
6. onDestroyView:该回调方法在视图层次结构与Fragment分离之后调用。
7. onDestroy：不再使用Fragment时调用。（备注：Fragment仍然附加到Activity并任然可以找到，但是不能执行其他操作）
8. onDetach：Fragme生命周期最后回调函数，调用后，Fragment不再与Activity绑定，释放资源。
9. setRetainInstance（true），是可以在Activity重新创建时可以不完全销毁Fragment，以便Fragment可以恢复

**总结**：关于Activity和Fragment的生命周期图，如下所示：

![](https://imgs.piasy.com/2018-03-23-2017010890963complete_android_fragment_lifecycle.png)

#### 3.AsyncTask 的原理，以及它的缺陷和问题。

