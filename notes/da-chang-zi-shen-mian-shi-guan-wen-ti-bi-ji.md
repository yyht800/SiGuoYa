# 大厂资深面试官——问题笔记

## 3-1. Java的char是两个字节，如何存UTF-8字符？

1. java中的char不存utf-8它存储的是UTF-16
2. Unicode 是字符集（存储了所有的符号），他的作用是将字符转换成码点，也就是从人类的认知翻译成计算机可识别的代码

   人类认知的字符=&gt;字符集=&gt;计算机存储

3. UTF-8是Unicode的一种实现方式，他是一种可变长度的编码方式，对于英文字母的UTF-8编码和ASCII码是相同的
4. java 中string 的length不是字符数而是char数组的长度，所以有时候会出现他的长度和字符数不想等的情况
5. 另外需要注意的是中文字符“中”获取UTF-16的字符长度为4个字节，比预计多出两个字节的，额外的两个字节是字符序

## 3-2. Java 的string 能有多长

1. 当String 存储在栈中
   * 受到字节码中CONSTANT\_UTF8\_info的限制，最终通过MUTF-8编码格式的字节数不能超过65535
   * 拉丁字符受到javac限制，最多是65534
   * 方法区大小的限制
2. 当String 存储在堆中
   * 受到虚拟机的指令限制，理论上最大值Integer.MAX\_VALUE
   * 实际可能小于理论上的值，虚拟机本身保留空间给头信息
   * 堆内存很小的话也会限制长度本身

## 3-3. Java的匿名内部类有哪些限制

1. 匿名内部类就是没有名字的内部类，只能继承一个父类或一个接口

   虚拟机中编译的匿名内部类其实是由名字的，比如外部类的路径$1

2. 匿名内部类分为静态和非静态
   * 静态匿名内部类

     静态匿名内部类不会持有外部引用

   * 非静态匿名内部类

     需要父类的外部实例来进行初始化
3. 匿名内部类的构造方法

   匿名内部类的构造方法是由编译器自动生成，当他是非静态的时候，默认的构造方法参数中会有外部的实例，以及自己外部类的实例

4. 只能捕获外部作用域内的final变量
5. java的中的匿名内部类不能被继承，kotlin 是可以的。

## 3-4怎样理解Java的方法分派

分派也就是java的多态的体现，他分为静态分派和动态分派

首先需要理解变量类型，比如：`Object obj = new String("");`

* 静态类型

  定义变量时声明的类型。这里的obj的静态类型就是Object，静态类型在编译期就确定了

* 实际类型

  obj的实际类型就是String，实际类型时在运行时确定的

然后我们在看静态分配和动态分配

* 静态分配 ——方法的重载

  根据变量的静态类型匹配调用方法的过程，他的字节码中显示，他是按照静态分派选择匹配静态类型的重载方法，而不是按照实际类型

* 动态分配——方法的重写

  根据变量的实际类型匹配调用方法的过程，就是动态分配。

  Java虚拟机在方法区中建立一个虚方法表（Virtual Method Table），通过使用方法表的索引来代替元数据查找以提高性能。虚方法表中存放着各个方法的实际入口地址（由于Java虚拟机自己建立并维护的方法表，所以没有必要使用符号引用，那不是跟自己过不去嘛），如果子类没有覆盖父类的方法，那么子类的虚方法表里面的地址入口与父类是一致的；如果重写父类的方法，那么子类的方法表的地址将会替换为子类实现版本的地址。

  方法表是在类加载的连接阶段（验证、准备、解析）进行初始化，准备了子类的初始化值后，虚拟机会把该类的虚方法表也进行初始化。

## 3-5 Java 的泛型的实现机制是怎么样的

1. 泛型的基本原理就是Java中的类型擦除。

   比如说List 和List都是List类型，如果是extends 的话则是有界类型，或者是通配符类型，都是泛型的一种。

   类型擦除是指，使用泛型时加上的类型参数，在编译时会去掉，最后得到编译后的产物（字节码）是不包含泛型参数的。

2. 类型擦除也会带来一些问题
   * 类型擦除后，如何保证只使用指定类型，编译器做了优化，先检查，再编译
   * 基本类型不能作为泛型实参，这就意味过程中会有装箱和拆箱的开销
   * 泛型类型无法作为方法重载（类型擦除后，参数类型是object），但是可以重写。编译器会自己生成两个桥方法，方法的参数类型就是object，桥方法的内部实现就是调用我们自己的重写方法。
   * 泛型无法作为真实的类型使用 比如数new一个对象等，这也是为什么Gson.fromJson需要传入Class的原因
   * 静态方法无法引用类泛型参数

     泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数。

   * 泛型在类型强转时会增加运行时开销
3. 类型擦除后获取泛型参数

   类型虽然被擦除了，但是被擦除的信息还是会以元素附加的签名信息，存储下来

   ```java
   // 获取类元素泛型
   ParameterizedType genericType = 
          (ParameterizedType)ConcreteClass.class.getGenericSuperClass();
   // 获取方法元素泛型
   ParameterizedType genericType =    (ParameterizedType)ConcreteClass.class.getMethod("getArray").getGenericReturnTypes、();
   ```

   需要在混淆时保护签名信息：

   ```java
   -keepattributes Signature
   ```

   一个很经典的例子，Gson构建泛型Type，实际上调用的就是`getGenericReturnTypes`方法：

   ```java
   Type genericType = new TypeToken<List<Integer>>(){}.getType();
   ```

## 3-6 Activity的onActivityResult为什么不设计成回调

1. onActivityResult会有些什么问题
   * 代码和逻辑分离，容易出现前后不一致的问题
   * 写法不够直观，且数据类型没有类型安全保障
   * onActivityResult返回结果很多的石斛显的非常臃肿
2. 能否用CallBack实现，假设从A跳转到B
   * 如果直接采用回调实现的话，当A在后台被销毁时，调用setResult的时候，会重建A得到A2，回调本身也是一个匿名内部类，他持有A的引用，无法满足需求
   * callback可以实现代码的简洁，但是存在上述问题，可以使用一个空Fragment——Dummy Fragment，利用Fragment作为中转，此时如果A被销毁的的时候，fragment也会被重建
3. fragment的唯一身份标识mWho，他的ID和tag等不可靠，利用他的唯一标识可以重新获取引用

## 4-1如何停止一个线程

1. Thread有直接暂停的方法——Stop，但是这个方法被废弃了，因为不安全
   * 暂停——Thread1在处理内存的时候加了锁，这时候他暂停了了，Thread1仍然持有锁，但是Thread1什么时候释放锁，不可知。
   * 被干掉——Thread1持有锁，被干掉的时候释放锁，但是Thread2去读取的时候内存状态是异常
2. Thread的间接停止方式——通知目标线程自行停止
   * interrupt 系统支持，出发方式是抛出异常，且调用JNI方法具有一定的开销
   * volatile 修饰对的Boolean  通过布尔值进行判断也可以抛出异常 （一般推荐）

## 4-2 如何写出线程安全的程序

1. 什么是线程安全本质是

   可变资源（内存）在线程间共享

2. 如何实现线程安全
   1. 不共享资源
      1. 纯函数
      2. ThreadLocal，本质是一个绑定到线程上的ThreadLocalMap
   2. 共享不可变资源
   3. 共享可变资源
      * 可见性——使用final关键字，使用volatile关键字， 加锁，锁释放的时候将缓存刷新到内存
      * 原子性
        * 加锁，保证操作的互斥性
        * 使用CAS指令
        * 使用原子数值类型
        * 使用原子属性更新器
      * 禁止重排序

## 4-3  ConcurrentHashMap如何支持并发访问

1. ConcurrentHashMap的并发优化
   * JDK 5：分段锁，（先获取高位，然后获取低位，较小整数的Hash高位都是15，退化成HashTable）
   * JDK6：优化Hash算法 （针对上面的情况优化，使Hash均匀分布）
   * JDK7：段懒加载，使用Volatile&CAS 
   * JDK8：摒弃段，基于HashMap的原理并发实现
2. ConcurrentHashMap是弱一致性的
   * 添加元素后不一定马上能读到
   * 清空之后可能仍然会有元素
   * 遍历之前的段元素的变化会读到
   * 遍历之后的段元素变化读不到
   * 遍历时元素发生变化不抛异常
3. HashTable的问题
   * 粗暴，各种加锁
4. 如何进行锁的优化
   * 长锁不如短锁，尽可能只锁必要的部分
   * 大锁不如小锁：尽可能对加锁的对象进行拆分
   * 公锁不如私锁：将锁的逻辑放到私有代码中
   * 尽量避免嵌套锁的使用
   * 将读和写的锁分离
   * 尽可能合并处理频繁过短的锁
   * 不加锁或用volatile替代锁

## 4-4 AtomicReference（AR）和AtomicReferenceFiledUpdater（ARFU）有何异同

两者都是利用UnSafe提供的CAS机制实现在多线程场景下安全的、原子的数据更新操作，区别主要有

* AR通常作为对象额成员使用，占16b（指针压缩）、24b（指针不压缩）
* AR使用更友好，ARFU更适合类实例比较多的场景
* ARFU通常作为类的静态成员使用，对实例成员进行修改
* AtomicReference是针对一个引用的增删改查做到线程安全
* AtomicReferenceFieldUpdater是针对一个对象的一个属性的增删改查做到线程安全
* AtomicReferenceFieldUpdate r操作属性的方式是通过反射，按属性名操作

## 4-5 如何在Android中写出优雅的一部代码？

1. 为什么要用异步？

   提高CPU利用率，提升GUI程序的响应速度，解决回调地狱的，代码可读性差的问题，但是异步不一定快.

2. 使用RxJava将异步逻辑扁平化，注意异常处理和取消处理
3. 使用kotlin协程将异步代码同步化，注意异常处理和取消操作

## 5-1 CPU架构适配需要注意哪些问题？

1. 兼容模式运行的一些问题
   1. 兼容模式运行的Native库无法获得最优的性能（所以x86的电脑上运行arm的虚拟机会很慢）
   2. 兼容那兼容模式容易出现一些难以排查的问题
   3. Native库加载优先会加载对应的目录，如果对应目录不存在，则会抛异常。（尽量提供完整的so库）
2. 对于性能不敏感的so库提供一个就行了，对于性能敏感的库可以提供基础版和兼容版（判断标准是的线上监控来完成）；
3. 非机动需要的（业务性不强的可以采用动态下发加载）；
4. 优化so的体积
   1. 默认隐藏所有符号，只公开必要的
   2. 禁用C++ Exception和RTTI
   3. 不要使用iostream 优先使用Android log
   4. 去除无用的代码
   5. 利用gradle构建时分包，加载对应的库
5. SDK开发者需要注意什么
   1. 尽量不在Native层开发，降低维护成本
   2. 尽量优化Native库的体积，降低使用成本
   3. 提供完整的CPU架构

## 5.2 Java Native方法与Native函数是怎么绑定的

绑定的方式分为静态方式和动态方式

1. 静态方式 通过命名规则映射
2. 动态绑定： 通过JNI函数注册
   1. 动态绑定可以在任何时刻触发
   2. 动态绑定之前根据静态规则查找Native函数
   3. 动态绑定后可以在绑定后任意时间取消
3. 静态绑定和动态绑定两者的区别

   |  | 静态绑定 | 动态绑定 |
   | :---: | :---: | :---: |
   | Native函数名 | 按照固有规则编写并采用C的命名规则 | 无要求 |
   | Native函数可见性 | 可见 | 无要求 |
   | 动态更换 | 否 | 能 |
   | 调用性能 | 额外查找开销 | 无需查找 |
   | 开发影响 | 重构繁琐（例如：修改函数名，需两边同时改） | 几乎无副作用 |
   | AndroidStudio支持 | 自动关联Native函数跳转 | 不能自动关联 |

## 5.3 JNI如何实现数据传递的

1. 通过long类型传递底层对象指针给java层（todo 看下Android 进阶解密）

## 5.4 如何全局捕获Native异常

1. 捕获Native异常
   1. Native层捕获异常的signal信号
   2. 通过反射找到java的class，将异常传递到java层（涉及到classloader）

## 5.5 只有C、C++ 可以编写JNI的Native库么

1. JNI对Native函数的要求
   1. 静态绑定
      * 符号表可见
      * 命名符合Java Native方法的包名_类名_方法名
      * 符号按照C语言的规则修饰
   2. 动态绑定
      * 函数本身无要求
      * JNI可识别入口函数如JNI\_onLoad 进行注册即可
2. 可选的Native语言
   1. Golang
   2. Rust
   3. Kotlin Native
   4. Scala Native

## 6-1 Activity的启动流程是怎样的？

详细分析过，略

## 6-2 如何跨App启动Activity

几种启动的方式：

1. 共享uid 的app
2. 使用exported
3. 使用intentFilter

可外部启动的Activity需要注意拒绝服务漏洞（如序列化的问题）

尽量不暴露Activity，为暴露的Activity增加控制权限

## 6-3 如何解决Activity参数类型安全及接口繁琐的问题

1. Activity参数传递存在的问题
   * 类型安全 bundle k-v在编译器不能保证类型
   * 接口繁琐，启动Activity的参数和结果都一来intent
2. 可以设计一个注解处理器简化参数传递，设计需要注意几个方面
   * 注解类的继承关系
   * 标注类的为内部类的
   * kotlin与java的类型映射的问题
   * 代码生成和直接依赖的边界

## 6-4 如何在代码的任意位置为当前的Activity添加view

1. 如何在任意位置获取当前的Activity

   通过ActivityLifeCallback做一个自己的ActivityManager（使用弱引用，避免内存泄漏）

2. 添加普通View
   1. 通过R.id.content获取contentView
   2. 使用contentView添加和移除view
3. 添加全局View

   需要进行技术选型和探讨

4. java的GC

   在另一个文章中详细讲述了

## 6-5 如何实现类似微信右滑返回的效果

1. fragment的实现

   fragment实现基本就是view级别的操作，只要实现View随手势滑动的效果就好了

2. Activity的实现
   1. 设置背景透明
   2. 不同栈的Activity，如ABC 其中B在task1，AC在Task0，当C移除的时候回先闪现A，然后到B，可以使用B的快照，替代一下的过场。
   3. Activity的栈的获取可以根据Taskid
   4. Activity的透明状态对生命周期的影响

      onPause和onStop区别

   5. 透明切换的时候可能会导致问题，可以通过一个隐藏的方法convertToTranslucent方法，切换透明度。

## 7-1Android中为什么非UI线程不能更新UI

1. UI线程是什么

   ActivityThread，main方法里创建了一个Looper

2. 主要是叙述下消息机制（具体看另一篇文章）
3. 如果需要UI线程安全，会降低绘制效率
4. 非UI线程在特定情况下也可以更新UI
   1. surfaceView 给画布加锁，绘制，解锁（非UI线程绘制，UI线程负责显示）
   2. checkThread方法前

## 7-2 handler发送消息的delay可靠么

大于50ms的时候基本可靠，如果handler所属的线程压力很大（卡顿的时候），调用的时间并非delay的真实值，具体看消息机制，以及消息队列优化。

## 7-3 主线程的Looper为什么不会导致应用ANR

1. 什么是ANR

   Service，广播队列，content provider ，输入事件超时。ANR本身是主线程的一个耗时的监控。

2. Looper是一个整体进程上的概念，ANR是一个局部的监控。（ANR是Looper的一种应用）
3. 为什么不会导致CPU占用率高？

   没有消息的时候底层会阻塞，epoll\_wait方法。

## 7-4 如何实现自己的Handler-Looper框架

消息机制的复述，只需要涉及到java层，

## 8-1 如何避免OOM的产生

1. OOM的产生

   已使用的内存+新申请的内存&gt;可分配的内存 覆盖所有的内存区域吧。

2. 如何避免OOM

   1. 使用合适的数据结构，减少开销
   2. 内存复用（变成池，像是message）
   3. 避免使用枚举，（枚举类型，类型安全，可读性强，但是内存比int类型大）
   4. 使用Bitmap注意事项
      * 尽量使用合适的分辨率
      * 注意原始文件分辨率和内存缩放的结果
      * 不适用帧动画
      * 考虑对bitmap的重采样和复用配置
   5. 谨慎使用多进程
   6. 谨慎使用大堆（使用默认堆就可以了，堆大了会影响内存的回收效率）
   7. 使用NDK，相当于直接在物理内存进行分配了，比如游戏，地图之类

   小结：

   * Reduce 缩减：降低图片分辨率、重采样
   * Reuse 复用：池化策略、避免频繁创建对象，减小GC压力
   * Recycle 回收：主动销毁结束，避免内存泄漏，实现生命周期闭环
   * Refactor 重构：使用更适合的数据结构、更合理的程序结构
   * Revalue 重审：谨慎使用Large Heap，多进程，第三方框架

## 8-2 如何对图片进行缓存

LRU算法设计思路解释一下，Android中LRU底层就是借助了一个LinkedHashMap

## 8-3 如何计算图片缓存的大小

ARGB\_8888 和 RGB\_565（没有透明通道）

1. 图片体积优化
   1. 跟文件存储格式无关，（如jpg，png）
   2. 使用inSampleSize采样： 大图 转小图
   3. 使用矩阵变换放大图片：小图转大图
   4. 使用RGB\_565加载不透明的图片
   5. 使用9-patch作为图片
   6. 使用VectorDrawable或者动画替代图片

## 9-1 如何规避Android p对私有API的访问限制

Android P中对API设置了名单，限制了反射的访问，获取方法最后调用到Native的方法中，会对反射的来源进行判断是否合法，不合法的话，直接拒绝，如果需要绕过的话，需要在对应的判断中，通过hook的方式进行修改

## 9-2 如何实现换肤功能

1. 系统的换肤支持
   * 只支持替换主题中的配置的属性值
   * 资源中需要主动引用这些属性
   * 无法实现动态下载的业务需求
2. 动态去替换的资源包
   1. 先看下资源加载的大致流程

      context.getResources 通过Resources对应的API获取对应的资源，然后用AssetManager去加载对应的资源。

   2. 可修改的方式
      * 修改Resource，将Resource进行包装，对资源加载拦截，缺点是获取资源效率有影响，不支持Style assets目录
      * 替换AssetManager，侵入性最小，并AssetPath本身就支持多个资源
   3. AssetManager方案实现大致的思路
      * 需要注意的是代码动态添加的view可以修改LayoutInflater.Factory里面的方法
      * 皮肤包自愿的额差分方案

## 9-3 VirtualApk如何实现插件化

[滴滴插件化方案——hongyang](https://blog.csdn.net/lmj623565791/article/details/75000580)

## 9-4 Tinker如何实现热修复

1. 原理就是将新的Dex插入到Runtime老的dex前面
2. 重点就是基于dexDiff的差分算法（双指针同步处理，new和old 两个apk文件）
3. 资源的修复参考上面的章节AssetsMangager
4. 异常监控的，做了很好的闭环，以及良好的注释

## 10-1 如何开展优化类的工作

答题套路模板

1. 优化的目标
2. 通过监控找出的引起的最大问题，前期优先处理占比最大的问题（二八定律）
3. 业内横向对比
4. 完善指标的监控
5. 线上灰度
6. 项目收益
7. 人力优化

## 10-3 一个算法策略的优化

1. 优化前的项目状况
2. 量化指标
3. 算法比较的依据（参考算法模块）
4. 问题分析
5. 监控体系建设
6. 算法策略动态下发
7. 工具完善
8. 项目收益

## 10-4至12-1

略·1

